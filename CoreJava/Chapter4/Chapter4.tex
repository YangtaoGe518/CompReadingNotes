\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{comment}
\usepackage{listings}
\usepackage{mathtools}

\setlength{\parindent}{0em}
\setlength{\parskip}{0.5em}

\title{Objects and Classes}
\author{Yangtao Ge}
\date{\today}

\begin{document}
\maketitle

\section{Introduction to Object-Oriented Programming}
What is Object-Oriented Programming:\newline
Programming with several \textbf{objects}, each object has a specific functionality
which exposed to its users, but \underline{a hidden implementation}

Two Ways of thinking:
\begin{itemize}
    \item Traditional: algorithms $\rightarrow$ data structures\newline
    Note: fine for small problems but \textit{cannot} handle large problems.
    \item Morden: data structures $\rightarrow$ algorithms\newline
    Note: More efficient to \textbf{store} data first then \textbf manipulate them
\end{itemize}

\subsection{Classes}
Class $\xrightarrow{Construct}$ Instance $\xleftarrow{Use}$ program

\textbf{Encapsulation} is the key of OOP:
\begin{itemize}
\item \textbf{Definition}: It is combining data and behavior in one package and 
hiding the implementation detail from the users of the object
\item \textbf{How}: methods \emph{never} directly access instance field in a class than its own
i.e. ``Black Box behaviour''
\end{itemize}

\subsection{Objects}
Three characteristics:
\begin{itemize}
    \item behaviour:  what can it do + what can be done to it
    \item state: how does the object react when use its method
    \item identity: how is the object distinguish from others
\end{itemize}

\subsection{Identifying Classes}
A Common begin of OOP design: \underline{Identify} the classes and \underline{Add} methods to sperate classes

Rule of Naming:
\begin{itemize}
    \item Class Name: Nouns $\rightarrow$ What it is 
    \item Method Names: Verbs $\rightarrow$ What can it do
\end{itemize}

\subsection{Relationships between classes}
Common Relations are:
\begin{itemize}
    \item[\textbf{dependence}] ``uses-a'' Express a relationship one class manipulates another class
    \item[\textbf{aggregation}] ``has-a'' Express a relationship specifying the whole and its parts
    \item[\textbf{inheritance}] ``is-a'' Express a relationship between a more special and a more general class
\end{itemize}

UML(Unified Modeling Language) notations aree used to expressed the relationship by diagram\newline
Ref: \underline{p.131 Core Java, COMP0004 Note}

\section{Using Predefined Classes}
\subsection{Objects and Object Variables}
A constructor is a \textbf{special method} whose purpose is to \underline{construct} and \underline{initialize} objects 

Key facts between Object Variables and Objects:
\begin{itemize}
    \item a variable called ``deadline'' with type ``Date'' is not a object but a variable
    \item object variables need to be initialized
    \item object variables doesen't contains an object, but it only \emph{refers} to an object
    \item Explicitly, an object variable to \textbf{null} to indicate that it currently refers to no object
\end{itemize}

Two ways of INIT:
\begin{itemize}
    \item \textit{deadline = new Date();} refers to newly constructed object
    \item \textit{deadline = birthdate;} refers to an existing object
\end{itemize}

\subsection{The `LocalDate' Class of the Java Library}
\textit{Ref: pp. 135-137 Core Java}
\subsection{Mututator and Accessor Methods}
Definitions:
\begin{itemize}
    \item Mutator method: method which will change its own original value and return
    \item Accessor method: method which will \textbf{not} modify its original value  
\end{itemize}

\section{Defining Your Own Classes}
\subsection{Employee class}
Basic Structures of A Non-Main Class:
\begin{itemize}
    \item fields
    \item constructors i.e. could more than one constructor be found 
    \item methods
\end{itemize}

Source file(\textit{.java}) $\xrightarrow{compile}$ Compiled file(\textit{.class})

Example of \emph{Employee class} is as follows:
\lstinputlisting[language=Java]{employee.java}

\subsection{Use of Multiple Source Files}
Two ways of execute source Files:
\begin{itemize}
    \item ``javac Employee*.java'': all source files matching the wildcard will be comiled into class files
    \item ``javac EmployeeTest.java'': Find all classes mentiened in `EmployeeTest' Class, Then compiles it
\end{itemize}

\subsection{Dissecting the Employee Class}
public and private:
\begin{itemize}
    \item public: any methods in any class can call the method tagged with `public'
    \item private: only the methods that can access these instance fields or methods are in the \textit{Employee} class itself
\end{itemize}

\subsection{First Steps with Constructors}
Some Features of Constructors:
\begin{itemize}
    \item has the \textbf{name} as the class
    \item can only be called in \textbf{conjunction} with \emph{new} operator\newline
    i.e. james.Employee("James Bond") is \textbf{WORNG}
    \item can take zero, one, or more parameters
    \item has \textbf{no} return values
\end{itemize}

\subsection{Declaring Local Variable with `Var'}
\emph{var} keyword can replace with their type.(Valid from Java 10)
and it can only be used with \emph{local} variable inside methods.\newline
e.g.
\begin{lstlisting}[language=Java]
Employee harry = new Employee("Harry Porter", 50000, 1989, 10, 1)
\end{lstlisting}
is the valid as:
\begin{lstlisting}[language=Java]
var harry = new Employee("Harry Porter", 50000, 1989, 10, 1)
\end{lstlisting}

\subsection{Working with null Reference}
When using \emph{null} reference three cases could possible:
\begin{itemize}
    \item \textit{NullpointerException}: end of execution\newline
    two advantages:
    \begin{itemize}
        \item has the description of the problem
        \item finds the location of the problem
    \end{itemize}
    \item ``permissive'': turn a null argument to non-null\newline
    e.g.
    \begin{lstlisting}[language=Java]
    name = Objects.requireNoneNullElse(n, "unknown")
    \end{lstlisting}
    \item ``tough love'': reject a null argument\newline
    e.g.
    \begin{lstlisting}[language=Java]
    name = Objects.requireNoneNull(n, "Error with Null")
    \end{lstlisting}
\end{itemize}

\subsection{Implicit and Explicit Parameters}
Definition of these two parameters:
\begin{itemize}
    \item Implicit: the para appears \textit{before} the method name
    \item Explicit: the para \textit{in the paranthseses}
\end{itemize}
For example
\begin{lstlisting}[language=Java]
    number007.raiseSalary(5)
\end{lstlisting}
Here, \emph{number007} is Implicit para, \emph{5} is Explicit para.

\subsection{Benefits of Encapsulation}
Basic principle of Encapsulation:
\begin{itemize}
    \item A private data field
    \item Accessor (getter)
    \item Mutator (setter)
\end{itemize}

Two Benefits:
\begin{itemize}
    \item can \underline{change internal implementation} without affecting any code other than the method of the class
    \item can perform error checking which can protect from any unexpected input
\end{itemize}

\subsection{Class-Based Access Privileges}
Method could be valid for \textit{accessing the private data} of \textbf{all objects of its class} \newline
e.g. equal method:
\begin{lstlisting}[language=Java]
Class Employee{
    ...
    public boolean euqals(Employee other){
        return name.equals(other.name)
    }
}   
\end{lstlisting}
N.B. this method call name of the current object and and name of `other' which is another private field 

\subsection{Private Methods}
Usually are used in `help functions' to prevent accidentally call

\subsection{Final Instance Field}
Some Features of `Final': (needs more reading)
\begin{itemize}
    \item field value shoud be set after \textbf{the end of every constructor}
    \item the field may not be modified again
    \item usually used for \textit{primitive type fields} or \textit{immutable classes}\newline
    i.e. \emph{immutable class} means \underline{none} of its method ever mutate its object
\end{itemize}

\section{Static Fields and Methods}
\subsection{Static Fields}
\underline{Definition}: If you define a field \emph{static}, then thereis only one such field per \textbf{class}
(Not a instance)

Usually, it performs as a \textit{counter}, which indicates how many instances have been created.\newline
e.g.
\begin{lstlisting}[language=Java]
Class Employee{
    private static int nextId = 1;  //a static field
    private int id; 

    public void setId(){
        id = nextId;
        nextId++;
    }
}
\end{lstlisting}

Here, id belongs to each instance, but nextId belongs to the `\textbf{class Employee}'

\subsection{Static Constants}
Common to use `static' in constants:
\begin{itemize}
    \item \textbf{pi}: `public static final double PI = 3.1415926535...'
    \item \textbf{out}: `public static final PrintStream out = ...' i.e. this we commenly used 'System.out.println()'
\end{itemize}

Noticed that it is \underline{bad} to have public fields but it is \underline{good} to have public constants (usually tagged with `\textit{static final}')

\subsection{Static Methods}
\underline{Definition}: methods don't have a \textit{this} parameter(with no Implicit parameter)\newline
i.e.
\begin{itemize}
    \item static methods of \textit{Employee class} \underline{cannot} access the \emph{id} instance field
    \item static methods of \textit{Employee class} \underline{can} access a static field.
    \begin{lstlisting}[language=Java]
    int n = Employee.getNextId();
    \end{lstlisting}
\end{itemize}

Two situations to use Static method: when a method
\begin{itemize}
    \item doesn't need to access the object state(i.e. get info from Explicit paras)\newline
    e.g. `Math.Pow'
    \item only needs to \textit{access} static field of the class\newline
    e.g. `Employee.getNextId'
\end{itemize}

\subsection{Factory Methods}
\textit{Ref: pp.159-160} more reading needed

Why using Factory methods rather than constructors:
\begin{itemize}
    \item can't give \underline{diffrent} two names to constructors
    \item can't vary the \textbf{type} of the constructed object
\end{itemize}

\subsection{The main Method}
\emph{main} method is a static method.

Every class can have a main method for \underline{unit test}:
\begin{itemize}
    \item if testing Employee class in \textit{isolation} -- `java Employee'
    \item if it is a part of large program -- `java Application'
\end{itemize}



\end{document}