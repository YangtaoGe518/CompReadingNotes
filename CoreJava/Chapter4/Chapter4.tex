\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{comment}
\usepackage{listings}
\usepackage{mathtools}

\setlength{\parindent}{0em}
\setlength{\parskip}{0.5em}

\title{Objects and Classes}
\author{Yangtao Ge}
\date{\today}

\begin{document}
\maketitle

\section{Introduction to Object-Oriented Programming}
What is Object-Oriented Programming:\newline
Programming with several \textbf{objects}, each object has a specific functionality
which exposed to its users, but \underline{a hidden implementation}

Two Ways of thinking:
\begin{itemize}
    \item Traditional: algorithms $\rightarrow$ data structures\newline
    Note: fine for small problems but \textit{cannot} handle large problems.
    \item Morden: data structures $\rightarrow$ algorithms\newline
    Note: More efficient to \textbf{store} data first then \textbf manipulate them
\end{itemize}

\subsection{Classes}
Class $\xrightarrow{Construct}$ Instance $\xleftarrow{Use}$ program

\textbf{Encapsulation} is the key of OOP:
\begin{itemize}
\item \textbf{Definition}: It is combining data and behavior in one package and 
hiding the implementation detail from the users of the object
\item \textbf{How}: methods \emph{never} directly access instance field in a class than its own
i.e. ``Black Box behaviour''
\end{itemize}

\subsection{Objects}
Three characteristics:
\begin{itemize}
    \item behaviour:  what can it do + what can be done to it
    \item state: how does the object react when use its method
    \item identity: how is the object distinguish from others
\end{itemize}

\subsection{Identifying Classes}
A Common begin of OOP design: \underline{Identify} the classes and \underline{Add} methods to sperate classes

Rule of Naming:
\begin{itemize}
    \item Class Name: Nouns $\rightarrow$ What it is 
    \item Method Names: Verbs $\rightarrow$ What can it do
\end{itemize}

\subsection{Relationships between classes}
Common Relations are:
\begin{itemize}
    \item[\textbf{dependence}] ``uses-a'' Express a relationship one class manipulates another class
    \item[\textbf{aggregation}] ``has-a'' Express a relationship specifying the whole and its parts
    \item[\textbf{inheritance}] ``is-a'' Express a relationship between a more special and a more general class
\end{itemize}

UML(Unified Modeling Language) notations aree used to expressed the relationship by diagram\newline
Ref: \underline{p.131 Core Java, COMP0004 Note}

\section{Using Predefined Classes}
\subsection{Objects and Object Variables}
A constructor is a \textbf{special method} whose purpose is to \underline{construct} and \underline{initialize} objects 

Key facts between Object Variables and Objects:
\begin{itemize}
    \item a variable called ``deadline'' with type ``Date'' is not a object but a variable
    \item object variables need to be initialized
    \item object variables doesen't contains an object, but it only \emph{refers} to an object
    \item Explicitly, an object variable to \textbf{null} to indicate that it currently refers to no object
\end{itemize}

Two ways of INIT:
\begin{itemize}
    \item \textit{deadline = new Date();} refers to newly constructed object
    \item \textit{deadline = birthdate;} refers to an existing object
\end{itemize}

\subsection{The `LocalDate' Class of the Java Library}
\textit{Ref: pp. 135-137 Core Java}
\subsection{Mututator and Accessor Methods}
Definitions:
\begin{itemize}
    \item Mutator method: method which will change its own original value and return
    \item Accessor method: method which will \textbf{not} modify its original value  
\end{itemize}

\section{Defining Your Own Classes}
\subsection{Employee class}
Basic Structures of A Non-Main Class:
\begin{itemize}
    \item fields
    \item constructors i.e. could more than one constructor be found 
    \item methods
\end{itemize}

Source file(\textit{.java}) $\xrightarrow{compile}$ Compiled file(\textit{.class})

Example of \emph{Employee class} is as follows:
\lstinputlisting[language=Java]{employee.java}

\subsection{Use of Multiple Source Files}
Two ways of execute source Files:
\begin{itemize}
    \item ``javac Employee*.java'': all source files matching the wildcard will be comiled into class files
    \item ``javac EmployeeTest.java'': Find all classes mentiened in `EmployeeTest' Class, Then compiles it
\end{itemize}

\subsection{Dissecting the Employee Class}
public and private:
\begin{itemize}
    \item public: any methods in any class can call the method tagged with `public'
    \item private: only the methods that can access these instance fields or methods are in the \textit{Employee} class itself
\end{itemize}

\subsection{First Steps with Constructors}
Some Features of Constructors:
\begin{itemize}
    \item has the \textbf{name} as the class
    \item can only be called in \textbf{conjunction} with \emph{new} operator\newline
    i.e. james.Employee("James Bond") is \textbf{WORNG}
    \item can take zero, one, or more parameters
    \item has \textbf{no} return values
\end{itemize}

\subsection{Declaring Local Variable with `Var'}
\emph{var} keyword can replace with their type.(Valid from Java 10)
and it can only be used with \emph{local} variable inside methods.\newline
e.g.
\begin{lstlisting}[language=Java]
Employee harry = new Employee("Harry Porter", 50000, 1989, 10, 1)
\end{lstlisting}
is the valid as:
\begin{lstlisting}[language=Java]
var harry = new Employee("Harry Porter", 50000, 1989, 10, 1)
\end{lstlisting}

\subsection{Working with null Reference}
When using \emph{null} reference three cases could possible:
\begin{itemize}
    \item \textit{NullpointerException}: end of execution\newline
    two advantages:
    \begin{itemize}
        \item has the description of the problem
        \item finds the location of the problem
    \end{itemize}
    \item ``permissive'': turn a null argument to non-null\newline
    e.g.
    \begin{lstlisting}[language=Java]
    name = Objects.requireNoneNullElse(n, "unknown")
    \end{lstlisting}
    \item ``tough love'': reject a null argument\newline
    e.g.
    \begin{lstlisting}[language=Java]
    name = Objects.requireNoneNull(n, "Error with Null")
    \end{lstlisting}
\end{itemize}

\subsection{Implicit and Explicit Parameters}
Definition of these two parameters:
\begin{itemize}
    \item Implicit: the para appears \textit{before} the method name
    \item Explicit: the para \textit{in the paranthseses}
\end{itemize}
For example
\begin{lstlisting}[language=Java]
    number007.raiseSalary(5)
\end{lstlisting}
Here, \emph{number007} is Implicit para, \emph{5} is Explicit para.

\subsection{Benefits of Encapsulation}
Basic principle of Encapsulation:
\begin{itemize}
    \item A private data field
    \item Accessor (getter)
    \item Mutator (setter)
\end{itemize}

Two Benefits:
\begin{itemize}
    \item can \underline{change internal implementation} without affecting any code other than the method of the class
    \item can perform error checking which can protect from any unexpected input
\end{itemize}

\subsection{Class-Based Access Privileges}
Method could be valid for \textit{accessing the private data} of \textbf{all objects of its class} \newline
e.g. equal method:
\begin{lstlisting}[language=Java]
Class Employee{
    ...
    public boolean euqals(Employee other){
        return name.equals(other.name)
    }
}   
\end{lstlisting}
N.B. this method call name of the current object and and name of `other' which is another private field 

\subsection{Private Methods}
Usually are used in `help functions' to prevent accidentally call

\subsection{Final Instance Field}
Some Features of `Final': (needs more reading)
\begin{itemize}
    \item field value shoud be set after \textbf{the end of every constructor}
    \item the field may not be modified again
    \item usually used for \textit{primitive type fields} or \textit{immutable classes}\newline
    i.e. \emph{immutable class} means \underline{none} of its method ever mutate its object
\end{itemize}

\section{Static Fields and Methods}
\subsection{Static Fields}
\underline{Definition}: If you define a field \emph{static}, then thereis only one such field per \textbf{class}
(Not a instance)

Usually, it performs as a \textit{counter}, which indicates how many instances have been created.\newline
e.g.
\begin{lstlisting}[language=Java]
Class Employee{
    private static int nextId = 1;  //a static field
    private int id; 

    public void setId(){
        id = nextId;
        nextId++;
    }
}
\end{lstlisting}

Here, id belongs to each instance, but nextId belongs to the `\textbf{class Employee}'

\subsection{Static Constants}
Common to use `static' in constants:
\begin{itemize}
    \item \textbf{pi}: `public static final double PI = 3.1415926535...'
    \item \textbf{out}: `public static final PrintStream out = ...' i.e. this we commenly used 'System.out.println()'
\end{itemize}

Noticed that it is \underline{bad} to have public fields but it is \underline{good} to have public constants (usually tagged with `\textit{static final}')

\subsection{Static Methods}
\underline{Definition}: methods don't have a \textit{this} parameter(with no Implicit parameter)\newline
i.e.
\begin{itemize}
    \item static methods of \textit{Employee class} \underline{cannot} access the \emph{id} instance field
    \item static methods of \textit{Employee class} \underline{can} access a static field.
    \begin{lstlisting}[language=Java]
    int n = Employee.getNextId();
    \end{lstlisting}
\end{itemize}

Two situations to use Static method: when a method
\begin{itemize}
    \item doesn't need to access the object state(i.e. get info from Explicit paras)\newline
    e.g. `Math.Pow'
    \item only needs to \textit{access} static field of the class\newline
    e.g. `Employee.getNextId'
\end{itemize}

\subsection{Factory Methods}
\textit{Ref: pp.159-160} more reading needed

Why using Factory methods rather than constructors:
\begin{itemize}
    \item can't give \underline{diffrent} two names to constructors
    \item can't vary the \textbf{type} of the constructed object
\end{itemize}

\subsection{The main Method}
\emph{main} method is a static method.

Every class can have a main method for \underline{unit test}:
\begin{itemize}
    \item if testing Employee class in \textit{isolation} -- `java Employee'
    \item if it is a part of large program -- `java Application'
\end{itemize}

\section{Method Parameters}
\underline{Definition}
\begin{itemize}
    \item \textbf{call by value}: gets the \textit{value} that the caller provides
    \item \textbf{call by reference}: gets the \textit{location} of the variable that the caller provides
\end{itemize}

\underline{***\emph{Java Only use \textbf{call by value}}} \textit{(ref: pp.166-167 -- swap method)}

Two cases in java of method parameters:
\begin{itemize}
    \item \textbf{parameter variables}(Primitive types): methods \textit{cannot} modify the contents
    of any parameters variables passed to it.\newline
    e.g.
    \begin{lstlisting}[language=Java]
    public static void tripleValue(double){
        x = x * 3
    }
    double percent = 10
    tripleValue(percent)
    \end{lstlisting}
    \underline{what happens:}
    \begin{enumerate}
        \item x is init with a a copy of the value `percent' (x = 10)
        \item x is tripled(x = 30), percent remains (percent = 10)
        \item method ends, x is no longer used
    \end{enumerate}

    \item \textbf{Object variables}(Object references): it is easily \textit{possible} to implement Methods
    that change the state of an object parameter.\newline
    e.g.
    \begin{lstlisting}[language=Java]
    public static void tripleSalary(Employee x){
        x.raiseSalary(200)
    }
    harry = new Employee(...)
    tripleSalary(harry)
    \end{lstlisting}
    \begin{enumerate}
        \item x is init with \textit{a copy of} value of harry (object refernece)
        \item `raiseSalary' method is applied to the object refernece(the object \textit{harry} referred to get raised salary)
        \item methods ends, x is no longer used \textbf{BUT} \textit{harry} continues to refer to the employee object
    \end{enumerate}
\end{itemize}

\section{Object Construction}
This section mentiends mechanisms for writing constructors
\subsection{Overloading}
\underline{Definition:} Overloading occurs if several methods have the \textbf{same} name but \textbf{different} parameters
i.e. constructor is a special \underline{method}

the compile-time error occurs when:
\begin{itemize}
    \item there is \textit{no match} at all
    \item there is not one that is \textit{better} than \underline{all} others (?)
\end{itemize}

\subsection{Default Field Initialization}
The Default init:
\begin{itemize}
    \item number: \emph{0}
    \item boolean: \emph{false}
    \item object ref: \emph{null}
\end{itemize}

\subsection{The Constructor with No Arguments}
Two cases:
\begin{itemize}
    \item No constructor at all: get a \emph{free} \underline{no argument} constructor
    \item User defined constructor:
    \begin{itemize}
        \item have several Constructor: one with no argument
        \item can't use no argument mechanism
    \end{itemize}
\end{itemize}

\subsection{Explicit Field Initialization}
Two Ways of field init:
\begin{itemize}
    \item Assign a value:
    \begin{lstlisting}[language=Java]
    Class Employee{
        private String name = ``'';
    }   
    \end{lstlisting}
    \item Method call:
    \begin{lstlisting}[language=Java]
    Class Employee{
        private static int nextId;
        private int id = assignId();
        ... 
        private static int assignId(){
            int r = nextId;
            nextId++;
            return r;
        }
    }
    \end{lstlisting}
\end{itemize}
\subsection{Parameter Names}
Three types of parameter names:
\begin{itemize}
    \item single letter names
    \item prefix with `a' / `an'
    \item using \textit{this}\newline
    e.g.
    \begin{lstlisting}[language=Java]
    public Employee(String name, double salary){
        this.name = name;
        this.salary = salary;
    }
    \end{lstlisting}
\end{itemize}

\subsection{Calling Another Constructor}
Using \textit{this} to refer another constructor in the current class.\newline
e.g.
\begin{lstlisting}[language=Java]
public Employee(double s){
    // calls Employee(String, double)
    this("Employee #" nextId, s);
    nextId++;
}
\end{lstlisting}

\subsection{Initialization Blocks}
\underline{3 Types of initialization:}
\begin{itemize}
    \item setting value in a constructor
    \item assigning a value in the declaration
    \item initialization blocks
\end{itemize}

\underline{Process of running a constructor:}
\begin{enumerate}
    \item The first line of constructor call the another constructor -- execute the second constructor
    \item Otherwise,
    \begin{enumerate}
        \item All data fields are init to \emph{default}
        \item All field initilizers and init blocks are executed
    \end{enumerate} 
    \item Body is executed
\end{enumerate}

\subsection{Object Destruction and the \emph{finalize} Method}
Java is \underline{automatic garbage collection} -- \textbf{NO} destructors\newline
\textit{Ref: p.180 and Chapter 7}

\section{Packages}
\underline{Definition}: \textit{package} is a way of \textbf{grouping} classes in a collection
\subsection{Package Names}
Main Reason: guarantee the \underline{uniqueness} of class names.

Usually using \emph{Internet domain} names:\newline
e.g. \textit{horstmann.com $\rightarrow$ com.horstmann.corejava.Employee}

\subsection{Class Importation}
The process of thinking:
\begin{enumerate}
    \item import everything from a specific package/class: ``\emph{import java.time.*}''\newline
    (Never use `\emph{java.*}' with a prefix of `java' only)
    \item importing two classes but access the \underline{same} name: ``\emph{import java.util.Date}''\newline
    (Add a specific import statement to indicate what you want)
    \item need both class with the same name: use the \underline{full} package name with every class name
\end{enumerate}

\subsection{Static Imports}
Usuall used for Static class method to \textbf{shorten} the prefix\newline
e.g. \newline
\emph{Math.sqrt(Math.pow(x,2) + Math.pow(y,2))} should be abbreviated as\newline
\emph{sqrt(pow(x,2) + pow(y,2))} by `import'\newline
\emph{import static java.Math.*}

\subsection{Addition of a Class into a Package}
How: put the name of the package \textit{at the top} of the source file\newline
e.g.
\begin{lstlisting}[language=Java]
package come.horstmann.corejava

public class Employee{
    ... 
}
\end{lstlisting}

Two Cases of Running:
\begin{itemize}
    \item Use \underline{unnamed package}: `\emph{javac PackageTest.java}' \newline
    (running at the base dir only)
    \item Use \underline{named package:} `\emph{javac com/mycomany/PayrollApp.java}' \newline
    (running the \textbf{full path} of the dir)
\end{itemize}

\subsection{Package Access}
\emph{public} accessor of classes means classes in the same \underline{package} can have abilities to access
the public class. \newline
(N.B. \underline{unnamed package} can access --- defaultly has public accessor)

\subsection{The Class Path \& Jar Files}
It is related to JAR files(\textit{Ref: pp.189-198 \& Chapter 11}) \newline
Review this section later

Use IDE, automatically done.

\section{Documentation Comments}
\underline{This section mainly talk about `\emph{javadoc}' tool}

\subsection{Comment Insertion}
Follow items are extracted:
\begin{itemize}
    \item Modules
    \item Package
    \item Public Classes and Interfaces
    \item Public and Protected fields
    \item Public and Protected Constructor and Methods
\end{itemize}

The Grammar:
\begin{itemize}
    \item Documentation: \textbf{/** somewords */} (contains \textit{free-form text})
    \item Tags: \textbf{@sometag}
\end{itemize}

\subsection{Comments Detail}
\begin{itemize}
    \item Class: \textit{after} import statement, \textit{directly before} class definition\newline
    e.g.
    \begin{lstlisting}[language=Java]
 /**
   * A {@code Card} object represents a playing card, such
   * as ``Queen of Hearts''. A card has a suit (Diamond, Heart
   * Spade or Club) and a value (1 = Ace, 2 ... 10, 11 = Jack,
   * 12 = Queen, 13 = King)
   */
  public class Card{
   ...
  }
    \end{lstlisting}

    \item Method: immediately precede the method that it describes\newline 
    e.g.
    \begin{lstlisting}[language=Java]
 /**
  * Raise the salary of an employee,
  * @param byPercent the percentage by 
  *        which to raise the raiseSalary
  * @return the amount of the raise
  */
  public double raiseSalary(double byPercent){
    double raise = salary * bypercent / 100
    salary += raise
    return raise
  }
    \end{lstlisting}

    \item Field: generally for \underline{static constants}\newline
    e.g.
    \begin{lstlisting}[language=Java]
 /**
  * The ``Hearts'' card suit
  */
  public static final int HEART = 1;
    \end{lstlisting}
\end{itemize}
 
\subsection{General Comments}
Different Tags:
\begin{itemize}
    \item @since \emph{text}: description of the version that introduce the feature
    \item @author \emph{name}: author's name
    \item @version \emph{text}: ``version'' entry, description of current version
    \item @see \emph{reference}: adds a hyperlink or a place in the source code(class, method or variable)
    \begin{itemize}
        \item hyperlink:
        \begin{lstlisting}[language=html]
        @see <a href=``someWeb''>someLable</a>
        \end{lstlisting}     
        \item place in code:\newline
        \textit{@see com.horstmann.corejava.Employee\#raiseSalary(double)}
        \item plain text:
        \textit{@see ``Core Java 2 Volume 2''}
    \end{itemize}
    \item @index \emph{entry}: add an entry to the search box
\end{itemize}

\subsection{Package Comments}
Add a separate file in each \underline{package directory}
Two choices:
\begin{itemize}
    \item java file: ``package-info.java'' \newline
    /** output message */ + package
    \item HTML file: ``package.html'' 
    \begin{lstlisting}[language=html]
    <body> ... </body>
    \end{lstlisting}        
\end{itemize}

\subsection{Comment Extraction}
Steps:
\begin{enumerate}
    \item cd to the source file dir(contains `\emph{com.}' subdir)
    \item produce:
    \begin{itemize}
        \item `\emph{javadoc -d docDir nameOfPackage}': single package
        \item `\emph{javadoc -d docDir nameOfPackage1 nameOfPackage2}': Multiple Packages
        \item `\emph{javadoc -d docDir *.java}': unnamed package
    \end{itemize}
\end{enumerate}
\textit{Ref: javadoc in Oracle website}
\end{document}